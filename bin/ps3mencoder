#!/usr/bin/env perl

use strict;
use warnings;

use Cwd qw(abs_path getcwd);
use File::Spec;
use IPC::Cmd qw(can_run run); # core since 5.10.0
use POSIX qw(strftime);

use IO::All;
use List::MoreUtils qw(first_index);
use LWP::Simple qw(get head);
use YAML::XS qw(Load);

my @CONFIG_FILE_EXT   = qw(conf yml yaml); # valid extensions for the ps3mencoder config file
my $CWD               = abs_path(getcwd);  # current working directory
my $LOGFILE_PATH      = 'ps3mencoder.log'; # save alongside debug.log
my $LOGFILE           = io($LOGFILE_PATH); # debug log
my $SELF              = $0;                # full path to this executable
my $VERSION           = '0.40';            # logged to aid diagnostics
my $WINDOWS           = $^O eq 'MSWin32';  # is this running on Windows?
my $YOUTUBE           = qr{http://(?:\w+\.)?youtube\.com/watch\?v=([^&]+)}; # YouTube page (HTML)
my @YOUTUBE_FORMATS   = qw(22 18 6 5);     # YouTube formats id descending order of preference (see below)

=for comment

    mencoder http://movies.apple.com/movies/foo.mov -prefer-ipv4 \
        -nocache -quiet -oac lavc -of lavf -lavfopts format=dvd -ovc lavc \
        -lavcopts vcodec=mpeg2video:vbitrate=4096:threads=2:acodec=ac3:abitrate=128 \
        -ofps 24000/1001 -o /tmp/javaps3media/mencoder1261801759641

=cut

###################################################################################

sub debug($) {
    my $message = shift;
    my $now = strftime("%Y-%m-%d %H:%M:%S", localtime);

    $LOGFILE->append("$now: $VERSION: $$: $message", $/);
}

sub fatal($) {
    my $message = shift;

    debug "ERROR: $message";

    die "$SELF: $VERSION: $$: ERROR: $message", $/;
}

sub set($;$) {
    my ($name, $value) = @_;
    my $index = first_index { $_ eq $name } @ARGV;

    if ($index == -1) {
        if (defined $value) {
            debug "adding $name $value";
            push @ARGV, $name, $value;
        } else {
            debug "adding $name";
            push @ARGV, $name;
        }
    } elsif (defined $value) {
        if (ref($value) eq 'CODE') {
            local $_ = $ARGV[ $index + 1 ];
            my $old = $_;
            $value->();
            $ARGV[ $index + 1 ] = $_;
            debug "replaced $old with $_ in $name";
        } else {
            debug "setting $name to $value";
            $ARGV[ $index + 1 ] = $value;
        }
    }
}

sub subst($$$) {
    my ($name, $search, $replace) = @_;
    my $index = first_index { $_ eq $name } @ARGV;

    if ($index != -1) {
        debug "replacing $search with $replace in " . $ARGV[ $index + 1 ];
        $ARGV[ $index + 1 ] =~ s{$search}{$replace};
    }
}

sub add($;@) {
    my ($name, $value) = @_;

    if (defined $value) {
        debug "adding $name $value";
        push @ARGV, $name, $value;
    } else {
        debug "adding $name";
        push @ARGV, $name;
    }
}

# XXX unused
sub value($) {
    my $name = shift;
    my $index = first_index { $_ eq $name } @ARGV;

    if ($index == -1) {
        return undef;
    } else {
        return $ARGV[ $index + 1 ];
    }
}

sub isdef($) {
    my $name = shift;
    my $index = first_index { $_ eq $name } @ARGV;

    return ($index != -1);
}

sub isopt($) {
    my $arg = shift;
    return (defined($arg) && (substr($arg, 0, 1) eq '-'));
}

sub remove($) {
    my $name = shift;
    my @argv = @ARGV;
    my @keep;

    while (@argv) {
        my $arg = shift @argv;

        if (isopt($arg)) { # -foo ...
            if (@argv && not(isopt($argv[0]))) { # -foo bar
                my $value = shift @argv;

                if ($arg ne $name) {
                    push @keep, $arg, $value;
                }
            } elsif ($arg ne $name) { # just -foo
                push @keep, $arg;
            }
        } else {
            push @keep, $arg;
        }
    }

    if (@keep < @ARGV) {
        debug "removing $name";
        @ARGV = @keep;
    }
}

sub replace($@) {
    my ($old, @new) = @_;
    my $index = first_index { $_ eq $old } @ARGV;

    unless ($index == -1) {
        debug "replacing $old with @new";
        splice @ARGV, $index, 1, @new;
    }
}

sub mencoder(;$) {
    my $config = shift || {};
    my $mencoder_path;

    # we look for mencoder in these places (in desceneding order of priority):
    #
    # 1) the config file
    # 2) the path indicated by the environment variable $MENCODER_PATH
    # 3) the current working directory (prepended to the search path by IPC::Cmd::can_run)
    # 4) $PATH (via IPC::Cmd::can_run)

    my $mencoder = $config->{mencoder_path} || $ENV{MENCODER_PATH} || can_run('mencoder') || fatal("can't find mencoder");

    debug "exec: $mencoder" . (@ARGV ? " @ARGV" : '');

    my $ok = run(
        command => [ $mencoder, @ARGV ],
        verbose => 1
    );

    if ($ok) {
        debug 'ok';
    } elsif ($?) {
        fatal "can't exec mencoder: " . ($? >> 8);
    } else {
        debug 'exit status: 0';
    }

    exit 0;
}

=for comment

    {
        'profiles' => [
            {
                'mencoder' => {
                    '-quiet'   => undef,
                    'cache'    => '16384',
                    'lavcopts' => { '$' => ':level=41' }
                },
                'name' => 'Global',
                'uri'  => '^\\w+://.+$'
            },
            {
                'mencoder' => { 'user-agent' => 'Quicktime/7.6.4' },
                'name'     => 'Apple Trailers',
                'uri'      => '^http://(?:(?:movies|www)\\.)?apple\\.com/.+$'
            },
            {
                'mencoder' => { 'lavcopts' => { '4096' => '5086' } },
                'name'     => 'Apple Trailers HD',
                'uri'      => '^http://(?:(?:movies|www)\\.)?apple\\.com/.+\\.m4v$'
            }
        ],
        'version' => '0.2'
    }

=cut

sub process_config($) {
    my $uri = shift;
    my (@config, $config);
    
    # explicitly specify the full path to the config file
    if (exists $ENV{PS3MENCODER_CONF}) {
       push @config, $ENV{PS3MENCODER_CONF};
    }

    # search for it in the PMS home directory, e.g. alongside PMS.conf, if $PMS_HOME is defined
    if (exists $ENV{PMS_HOME}) {
       push @config, map { File::Spec->catfile($ENV{PMS_HOME}, "ps3mencoder.$_") } @CONFIG_FILE_EXT;
    }

    # If all else fails, look in the current working directory. This will be $PMS_HOME if ps3mencoder
    # is called by PMS
    push @config, map { File::Spec->catfile($CWD, "ps3mencoder.$_") } @CONFIG_FILE_EXT;

    for my $config_file (@config) {
        if (-f $config_file) {
            debug "loading config: $config_file";
            my $yaml = eval { io($config_file)->slurp() };
            fatal "can't open config: $@" if ($@);
            $config = eval { Load($yaml) };
            fatal "can't load config: $@" if ($@);
            last;
        }
    }

    if ($config) {
        # FIXME: this blindly assumes the config file is sane at the moment
        # XXX use Kwalify?

        if (defined $uri) {
            my $profiles = $config->{profiles};

            if ($profiles) {
                for my $profile (@$profiles) {
                    my $profile_name = $profile->{name};
                    my $match        = $profile->{uri};

                    if (defined($match) && ($uri =~ $match)) {
                        debug "matched profile: $profile_name";

                        while (my ($option_name, $option_value) = each(%{ $profile->{mencoder} })) {
                            $option_name =~ s{^([-+]?)}{-};

                            if (ref $option_value) {
                                while (my ($search, $replace) = each(%$option_value)) {
                                    subst($option_name, $search, $replace);
                                }
                            } else {
                                my $op;

                                if ($1 eq '-') {
                                    $op = \&remove;
                                } elsif ($1 eq '+') {
                                    $op = \&add;
                                } else {
                                    $op = \&set;
                                }

                                $op->($option_name, $option_value);
                            }
                        }
                    }
                }
            } else {
                debug 'no profiles defined';
            }
        } else {
            debug 'no URI defined';
        }
    } else {
        require Data::Dumper;
        $Data::Dumper::Terse = 1;
        $Data::Dumper::Indent = 0;
        debug "can't find ps3mencoder config file in: " . Data::Dumper::Dumper(\@config);
    }

    return $config; # may be undef
}

sub handle_youtube($$) {
    my ($uri, $config) = @_;
    # extract the media URI - see http://stackoverflow.com/questions/1883737/getting-an-flv-from-youtube-in-net
    my $id = $1;
    my $html = get($uri) || fatal "couldn't retrieve $uri";
    my ($signature) = $html =~ m{"t":\s*"([^"]+)"};
    my $found = 0;

    # via http://www.longtailvideo.com/support/forum/General-Chat/16851/Youtube-blocked-http-youtube-com-get-video
    #
    # No &fmt = FLV (very low)
    # &fmt=5  = FLV (very low)
    # &fmt=6  = FLV (doesn't always work)
    # &fmt=13 = 3GP (mobile phone)
    # &fmt=18 = MP4 (normal)
    # &fmt=22 = MP4 (hd)
    #
    # see also:
    #
    #     http://tinyurl.com/y8rdcoy
    #     http://userscripts.org/topics/18274

    for my $fmt (@YOUTUBE_FORMATS) {
        my $media_uri = "http://www.youtube.com/get_video?fmt=$fmt&video_id=$id&t=$signature";
        next unless (head $media_uri);
        $ARGV[0] = $media_uri;
        $found = 1;
        last;
    }

    fatal "can't retrieve YouTube video from $uri" unless ($found);
}

###################################################################################

$| = 1; # unbuffer output
$LOGFILE->append($/) if (-s $LOGFILE_PATH);

# on Win32, the config file should be in $PMS_HOME, typically C:\Program Files\PS3 Media Server
# Unfortunately, PMS' registry entries are currently broken, so we can't rely on them (e.g. we
# can't use Win32::TieRegistry):
#
#     http://code.google.com/p/ps3mediaserver/issues/detail?id=555
#
# Instead we bundle the default config file (and mencoder.exe) in $PS3MENCODER_HOME/res
# and ensure they're picked up with a reasonably high priority by setting them as
# environment variables

if ($WINDOWS) {
    eval 'use Cava::Pack';
    fatal "can't load Cava::Pack: $@" if ($@);
    Cava::Pack::SetResourcePath('res');
    $ENV{PS3MENCODER_CONF} ||= Cava::Pack::Resource('ps3mencoder.conf');
    $ENV{MENCODER_PATH} ||= Cava::Pack::Resource('mencoder.exe');
    $SELF = abs_path(File::Spec->catfile(Cava::Pack::Resource(''), File::Spec->updir, 'ps3mencoder.exe'));
}

debug $SELF . (@ARGV ? " @ARGV" : '');

my $config = process_config($ARGV[0]); # load the config and process matching profiles

# web video streaming: fix mencoder options, handle YouTube videos, and process config file
if (isdef('-prefer-ipv4') && isdef('-ovc')) {
    # special-case YouTube
    # XXX add config support for this kind of handling (i.e. redirection)
    # if there are more examples like this

    if ($ARGV[0] =~ $YOUTUBE) {
        handle_youtube($ARGV[0], $config); # changes $ARGV[0]
    }

    # quote the URI - IPC::Cmd doesn't handle special characters (e.g. ampersands) when passing URIs to /bin/sh
    $ARGV[0] =~ s{"}{%22}g;
    $ARGV[0] = qq{"$ARGV[0]"};
}

mencoder($config);
